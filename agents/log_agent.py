# Auto-generated by Manus: Chaos Triage Arena scaffold

import json
import time
import argparse
import sys
from pathlib import Path
from fastapi import FastAPI
import uvicorn
import requests


class LogAgent:
    """Agent for analyzing service logs and error patterns"""
    
    def __init__(self, port: int):
        self.port = port
        self.app = FastAPI(title="LogAgent")
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.post("/run")
        async def run_analysis(step_data: dict):
            """Execute log analysis step"""
            try:
                result = self.analyze_logs(step_data)
                return {"success": True, "result": result}
            except Exception as e:
                return {"success": False, "error": str(e)}
    
    def analyze_logs(self, step_data: dict) -> dict:
        """Analyze logs for the target service"""
        target_service = step_data.get("target_service", "unknown")
        step_type = step_data.get("step", "analyze_logs")
        
        # Simulate log analysis by checking service logs directory
        logs_dir = Path("service_logs")
        stdout_log = logs_dir / f"{target_service}_stdout.log"
        stderr_log = logs_dir / f"{target_service}_stderr.log"
        
        analysis_result = {
            "service": target_service,
            "step": step_type,
            "timestamp": time.time(),
            "log_files_checked": [],
            "error_patterns": [],
            "warnings": [],
            "recommendations": []
        }
        
        # Check stdout log
        if stdout_log.exists():
            analysis_result["log_files_checked"].append(str(stdout_log))
            try:
                with open(stdout_log, 'r') as f:
                    lines = f.readlines()[-50:]  # Last 50 lines
                    
                # Look for error patterns
                for line in lines:
                    line_lower = line.lower()
                    if any(pattern in line_lower for pattern in ["error", "exception", "failed", "timeout"]):
                        analysis_result["error_patterns"].append(line.strip())
                    elif any(pattern in line_lower for pattern in ["warning", "warn"]):
                        analysis_result["warnings"].append(line.strip())
                        
            except Exception as e:
                analysis_result["error_patterns"].append(f"Failed to read stdout log: {e}")
        
        # Check stderr log
        if stderr_log.exists():
            analysis_result["log_files_checked"].append(str(stderr_log))
            try:
                with open(stderr_log, 'r') as f:
                    lines = f.readlines()[-50:]  # Last 50 lines
                    
                for line in lines:
                    if line.strip():  # Non-empty lines in stderr are usually errors
                        analysis_result["error_patterns"].append(f"STDERR: {line.strip()}")
                        
            except Exception as e:
                analysis_result["error_patterns"].append(f"Failed to read stderr log: {e}")
        
        # Generate recommendations based on findings
        if analysis_result["error_patterns"]:
            analysis_result["recommendations"].append("Service has error patterns in logs - investigate and restart")
        elif not analysis_result["log_files_checked"]:
            analysis_result["recommendations"].append("No log files found - service may not have started properly")
        else:
            analysis_result["recommendations"].append("No obvious errors in recent logs - check service configuration")
        
        # Try to get recent logs from service if it's running
        try:
            response = requests.get(f"http://127.0.0.1:8001/logs", timeout=3)  # Try api_gateway port as example
            if response.status_code == 200:
                service_logs = response.json()
                analysis_result["service_logs"] = service_logs.get("recent_logs", [])
        except:
            pass  # Service might be down
        
        return analysis_result
    
    def run(self):
        """Run the LogAgent server"""
        print(f"LogAgent starting on port {self.port}")
        uvicorn.run(self.app, host="127.0.0.1", port=self.port, log_level="warning")


def main():
    parser = argparse.ArgumentParser(description="LogAgent - Service log analysis")
    parser.add_argument("--port", type=int, required=True, help="Port to listen on")
    parser.add_argument("--step-data", type=str, help="JSON step data")
    
    args = parser.parse_args()
    
    # If step-data provided, run once and exit
    if args.step_data:
        try:
            step_data = json.loads(args.step_data)
            agent = LogAgent(args.port)
            result = agent.analyze_logs(step_data)
            print(json.dumps(result))
            sys.exit(0)
        except Exception as e:
            print(json.dumps({"success": False, "error": str(e)}))
            sys.exit(1)
    
    # Otherwise run as server
    agent = LogAgent(args.port)
    agent.run()


if __name__ == "__main__":
    main()

