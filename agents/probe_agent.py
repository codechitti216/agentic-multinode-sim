# Auto-generated by Manus: Chaos Triage Arena scaffold

import json
import time
import argparse
import sys
from fastapi import FastAPI
import uvicorn
import requests
import socket


class ProbeAgent:
    """Agent for testing service connectivity and dependencies"""
    
    def __init__(self, port: int):
        self.port = port
        self.app = FastAPI(title="ProbeAgent")
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.post("/run")
        async def run_probe(step_data: dict):
            """Execute probe step"""
            try:
                result = self.execute_probe(step_data)
                return {"success": True, "result": result}
            except Exception as e:
                return {"success": False, "error": str(e)}
    
    def execute_probe(self, step_data: dict) -> dict:
        """Execute probe based on step type"""
        target_service = step_data.get("target_service", "unknown")
        step_type = step_data.get("step", "probe_service")
        
        probe_result = {
            "service": target_service,
            "step": step_type,
            "timestamp": time.time(),
            "probes_executed": [],
            "connectivity_status": {},
            "dependency_status": {},
            "recommendations": []
        }
        
        try:
            if step_type in ["probe_service", "probe_system"]:
                result = self.probe_service_health(target_service)
                probe_result["probes_executed"].append("service_health")
                probe_result["connectivity_status"] = result
                
            elif step_type in ["probe_dependencies", "check_dependencies"]:
                result = self.probe_dependencies(target_service)
                probe_result["probes_executed"].append("dependencies")
                probe_result["dependency_status"] = result
                
            else:
                # Generic probe - check both service and dependencies
                service_result = self.probe_service_health(target_service)
                deps_result = self.probe_dependencies(target_service)
                probe_result["probes_executed"].extend(["service_health", "dependencies"])
                probe_result["connectivity_status"] = service_result
                probe_result["dependency_status"] = deps_result
            
            # Generate recommendations based on probe results
            probe_result["recommendations"] = self.generate_recommendations(probe_result)
            
        except Exception as e:
            probe_result["error"] = str(e)
        
        return probe_result
    
    def probe_service_health(self, service_name: str) -> dict:
        """Probe service health and connectivity"""
        service_ports = {
            "api_gateway": 8001,
            "database_service": 8002,
            "user_service": 8003,
            "payment_service": 8004,
            "echo_service": 8005
        }
        
        if service_name not in service_ports:
            return {"error": f"Unknown service: {service_name}"}
        
        port = service_ports[service_name]
        result = {
            "service": service_name,
            "port": port,
            "port_open": False,
            "healthz_status": None,
            "status_endpoint": None,
            "response_time_ms": None,
            "endpoints_tested": []
        }
        
        # Test port connectivity
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(3)
                connection_result = sock.connect_ex(('127.0.0.1', port))
                result["port_open"] = connection_result == 0
        except Exception as e:
            result["port_error"] = str(e)
        
        if result["port_open"]:
            # Test /healthz endpoint
            try:
                start_time = time.time()
                response = requests.get(f"http://127.0.0.1:{port}/healthz", timeout=5)
                response_time = (time.time() - start_time) * 1000
                
                result["healthz_status"] = response.status_code
                result["response_time_ms"] = round(response_time, 2)
                result["endpoints_tested"].append("/healthz")
                
                if response.status_code == 200:
                    result["healthz_response"] = response.json()
                
            except Exception as e:
                result["healthz_error"] = str(e)
            
            # Test /status endpoint
            try:
                response = requests.get(f"http://127.0.0.1:{port}/status", timeout=5)
                result["status_endpoint"] = response.status_code
                result["endpoints_tested"].append("/status")
                
                if response.status_code == 200:
                    result["status_response"] = response.json()
                
            except Exception as e:
                result["status_error"] = str(e)
            
            # Test service-specific endpoints
            service_endpoints = self.get_service_endpoints(service_name)
            for endpoint in service_endpoints:
                try:
                    response = requests.get(f"http://127.0.0.1:{port}{endpoint}", timeout=3)
                    result[f"endpoint_{endpoint.replace('/', '_')}"] = response.status_code
                    result["endpoints_tested"].append(endpoint)
                except Exception as e:
                    result[f"endpoint_{endpoint.replace('/', '_')}_error"] = str(e)
        
        return result
    
    def probe_dependencies(self, service_name: str) -> dict:
        """Probe service dependencies"""
        # Service dependency mapping from arena.json
        dependencies = {
            "api_gateway": ["user_service", "payment_service"],
            "database_service": [],
            "user_service": ["database_service"],
            "payment_service": ["database_service"],
            "echo_service": []
        }
        
        service_deps = dependencies.get(service_name, [])
        
        result = {
            "service": service_name,
            "dependencies": service_deps,
            "dependency_results": {},
            "all_dependencies_healthy": True
        }
        
        for dep_service in service_deps:
            dep_result = self.probe_service_health(dep_service)
            result["dependency_results"][dep_service] = dep_result
            
            # Check if dependency is healthy
            is_healthy = (
                dep_result.get("port_open", False) and
                dep_result.get("healthz_status") == 200
            )
            
            if not is_healthy:
                result["all_dependencies_healthy"] = False
        
        return result
    
    def get_service_endpoints(self, service_name: str) -> list:
        """Get service-specific endpoints to test"""
        endpoints = {
            "api_gateway": ["/api/users", "/api/payments"],
            "database_service": ["/query", "/users", "/payments"],
            "user_service": ["/users", "/validate"],
            "payment_service": ["/payments", "/process"],
            "echo_service": ["/echo", "/ping", "/info"]
        }
        
        return endpoints.get(service_name, [])
    
    def generate_recommendations(self, probe_result: dict) -> list:
        """Generate recommendations based on probe results"""
        recommendations = []
        
        connectivity = probe_result.get("connectivity_status", {})
        dependencies = probe_result.get("dependency_status", {})
        
        # Service connectivity recommendations
        if not connectivity.get("port_open", False):
            recommendations.append("Service port is not accessible - check if service is running")
        elif connectivity.get("healthz_status") != 200:
            recommendations.append("Service health check failing - investigate service state")
        elif connectivity.get("response_time_ms", 0) > 1000:
            recommendations.append("Service response time is high - check for performance issues")
        
        # Dependency recommendations
        if dependencies and not dependencies.get("all_dependencies_healthy", True):
            unhealthy_deps = []
            for dep_name, dep_result in dependencies.get("dependency_results", {}).items():
                if not (dep_result.get("port_open", False) and dep_result.get("healthz_status") == 200):
                    unhealthy_deps.append(dep_name)
            
            if unhealthy_deps:
                recommendations.append(f"Unhealthy dependencies detected: {', '.join(unhealthy_deps)}")
                recommendations.append("Fix dependency issues before addressing main service")
        
        # Endpoint-specific recommendations
        endpoints_tested = connectivity.get("endpoints_tested", [])
        for endpoint in endpoints_tested:
            endpoint_key = f"endpoint_{endpoint.replace('/', '_')}"
            if endpoint_key in connectivity and connectivity[endpoint_key] != 200:
                recommendations.append(f"Endpoint {endpoint} is not responding correctly")
        
        if not recommendations:
            recommendations.append("All probes successful - service and dependencies appear healthy")
        
        return recommendations
    
    def run(self):
        """Run the ProbeAgent server"""
        print(f"ProbeAgent starting on port {self.port}")
        uvicorn.run(self.app, host="127.0.0.1", port=self.port, log_level="warning")


def main():
    parser = argparse.ArgumentParser(description="ProbeAgent - Service connectivity and dependency testing")
    parser.add_argument("--port", type=int, required=True, help="Port to listen on")
    parser.add_argument("--step-data", type=str, help="JSON step data")
    
    args = parser.parse_args()
    
    # If step-data provided, run once and exit
    if args.step_data:
        try:
            step_data = json.loads(args.step_data)
            agent = ProbeAgent(args.port)
            result = agent.execute_probe(step_data)
            print(json.dumps(result))
            sys.exit(0)
        except Exception as e:
            print(json.dumps({"success": False, "error": str(e)}))
            sys.exit(1)
    
    # Otherwise run as server
    agent = ProbeAgent(args.port)
    agent.run()


if __name__ == "__main__":
    main()

