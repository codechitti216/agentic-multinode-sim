# Auto-generated by Manus: Chaos Triage Arena scaffold

import time
import os
import sys
import json
import subprocess
import socket
import threading
from pathlib import Path
from typing import Dict, List, Any, Optional

# Add parent directory to path to import modules
sys.path.append(str(Path(__file__).parent.parent))

from super_tool import SuperTool
from planner.stub_planner import StubPlanner
from planner.llm_adapter import LLMAdapter


class FelixAgent:
    """Felix Commander - Incident detection and response orchestration"""
    
    def __init__(self):
        self.check_interval = int(os.getenv("FELIX_INTERVAL", "5"))
        self.super_tool = SuperTool()
        self.stub_planner = StubPlanner()
        self.llm_adapter = LLMAdapter()
        
        # Active incidents and plans
        self.active_incidents: Dict[str, Dict[str, Any]] = {}
        self.active_plans: Dict[str, List[Dict[str, Any]]] = {}
        self.agent_processes: Dict[str, subprocess.Popen] = {}
        
        # Agent port allocation
        self.next_agent_port = 9000
        self.agent_ports: Dict[str, int] = {}
        
        self.running = True
        
    def log(self, message: str):
        """Log message with timestamp"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] [FELIX] {message}")
    
    def find_free_port(self) -> int:
        """Find a free port for agent communication"""
        while True:
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.bind(('127.0.0.1', self.next_agent_port))
                    port = self.next_agent_port
                    self.next_agent_port += 1
                    return port
            except OSError:
                self.next_agent_port += 1
                if self.next_agent_port > 9100:  # Prevent infinite loop
                    raise Exception("No free ports available")
    
    def detect_incidents(self) -> List[Dict[str, Any]]:
        """Detect incidents by analyzing service status and metrics"""
        incidents = []
        
        try:
            statuses = self.super_tool.get_all_statuses()
            metrics = self.super_tool.get_all_metrics()
            
            for service_name, status in statuses.items():
                # Check for new incidents
                incident_key = f"{service_name}_incident"
                
                # Determine if this is an incident
                is_incident = False
                incident_type = None
                
                if not status.get("running", False):
                    is_incident = True
                    incident_type = "service_down"
                elif not status.get("healthy", False):
                    is_incident = True
                    incident_type = "service_unhealthy"
                else:
                    # Check metrics for performance issues
                    service_metrics = metrics.get(service_name, {})
                    cpu_percent = service_metrics.get("cpu_percent", 0)
                    memory_mb = service_metrics.get("memory_mb", 0)
                    is_failed = service_metrics.get("is_failed", False)
                    
                    if is_failed or cpu_percent > 80 or memory_mb > 500:
                        is_incident = True
                        incident_type = "performance_issue"
                
                if is_incident:
                    # Check if this is a new incident
                    if incident_key not in self.active_incidents:
                        incident = {
                            "id": incident_key,
                            "service": service_name,
                            "type": incident_type,
                            "status": status,
                            "metrics": metrics.get(service_name, {}),
                            "detected_at": time.time(),
                            "resolved": False
                        }
                        incidents.append(incident)
                        self.active_incidents[incident_key] = incident
                        self.log(f"New incident detected: {incident_type} in {service_name}")
                else:
                    # Check if incident is resolved
                    if incident_key in self.active_incidents:
                        self.active_incidents[incident_key]["resolved"] = True
                        self.log(f"Incident resolved: {service_name}")
        
        except Exception as e:
            self.log(f"Error detecting incidents: {e}")
        
        return incidents
    
    def generate_recovery_plan(self, incident: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate recovery plan for incident"""
        # Try LLM first if available
        if self.llm_adapter.is_available():
            self.log(f"Generating LLM plan for incident {incident['id']}")
            llm_plan = self.llm_adapter.generate_plan(incident)
            if llm_plan:
                return llm_plan
            else:
                self.log("LLM plan generation failed, falling back to stub planner")
        
        # Fall back to stub planner
        self.log(f"Generating stub plan for incident {incident['id']}")
        return self.stub_planner.generate_plan(incident)
    
    def spawn_agent(self, agent_type: str, step: Dict[str, Any]) -> Optional[subprocess.Popen]:
        """Spawn an agent process to execute a step"""
        # Map class-like agent names to file names
        agent_filename_map = {
            "LogAgent": "log_agent.py",
            "MetricAgent": "metric_agent.py",
            "ProbeAgent": "probe_agent.py",
            "ActionAgent": "action_agent.py",
        }
        script_name = agent_filename_map.get(agent_type, f"{agent_type.lower()}.py")
        agent_script = Path(f"agents/{script_name}")
        
        if not agent_script.exists():
            self.log(f"Agent script not found: {agent_script}")
            return None
        
        try:
            # Allocate port for agent
            port = self.find_free_port()
            agent_id = f"{agent_type}_{step['id']}"
            
            # Prepare agent command
            cmd = [
                sys.executable, str(agent_script),
                "--port", str(port),
                "--step-data", json.dumps(step)
            ]
            
            # Start agent process
            process = subprocess.Popen(
                cmd,
                cwd=Path.cwd(),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            self.agent_processes[agent_id] = process
            self.agent_ports[agent_id] = port
            
            self.log(f"Spawned {agent_type} on port {port} for step {step['step']}")
            return process
            
        except Exception as e:
            self.log(f"Failed to spawn {agent_type}: {e}")
            return None
    
    def execute_step(self, step: Dict[str, Any]) -> Dict[str, Any]:
        """Execute a recovery step using appropriate agent"""
        agent_type = step["agent"]
        step_id = step["id"]
        
        self.log(f"Executing step: {step['step']} using {agent_type}")
        
        # Update step status
        step["status"] = "running"
        step["started_at"] = time.time()
        
        # Spawn agent
        process = self.spawn_agent(agent_type, step)
        
        if not process:
            return {"success": False, "error": "Failed to spawn agent"}
        
        # Wait for agent to complete (with timeout)
        try:
            stdout, stderr = process.communicate(timeout=30)
            
            if process.returncode == 0:
                # Try to parse agent result
                try:
                    result = json.loads(stdout.strip())
                except json.JSONDecodeError:
                    result = {"output": stdout.strip(), "error": stderr.strip()}
                
                self.log(f"Step {step['step']} completed successfully")
                return {"success": True, "result": result}
            else:
                self.log(f"Step {step['step']} failed with return code {process.returncode}")
                return {"success": False, "error": stderr.strip()}
                
        except subprocess.TimeoutExpired:
            process.kill()
            self.log(f"Step {step['step']} timed out")
            return {"success": False, "error": "Agent execution timed out"}
        except Exception as e:
            self.log(f"Error executing step {step['step']}: {e}")
            return {"success": False, "error": str(e)}
        finally:
            # Clean up
            agent_id = f"{agent_type}_{step_id}"
            if agent_id in self.agent_processes:
                del self.agent_processes[agent_id]
            if agent_id in self.agent_ports:
                del self.agent_ports[agent_id]
    
    def execute_plan(self, incident_id: str, plan: List[Dict[str, Any]]):
        """Execute recovery plan for incident"""
        self.active_plans[incident_id] = plan
        self.log(f"Starting plan execution for incident {incident_id} ({len(plan)} steps)")
        
        while not self.stub_planner.is_plan_complete(plan):
            # Get ready steps
            ready_steps = self.stub_planner.get_ready_steps(plan)
            
            if not ready_steps:
                # No ready steps, check if we're stuck
                pending_steps = [s for s in plan if s["status"] == "pending"]
                if pending_steps:
                    self.log(f"Plan execution stuck - no ready steps but {len(pending_steps)} pending")
                    # Mark first pending step as failed to unblock
                    pending_steps[0]["status"] = "failed"
                    pending_steps[0]["result"] = {"error": "Dependency deadlock"}
                break
            
            # Execute ready steps (could be parallel, but keeping simple for now)
            for step in ready_steps:
                result = self.execute_step(step)
                
                if result["success"]:
                    self.stub_planner.update_step_status(plan, step["id"], "completed", result["result"])
                else:
                    self.stub_planner.update_step_status(plan, step["id"], "failed", result)
                
                # Record action in super_tool
                elapsed = time.time() - step.get("started_at", time.time())
                self.super_tool.record_action_event(
                    step.get("target_service", "unknown"),
                    f"felix_{step['step']}",
                    elapsed,
                    result
                )
            
            # Small delay between step executions
            time.sleep(1)
        
        # Plan execution complete
        summary = self.stub_planner.get_plan_summary(plan)
        self.log(f"Plan execution complete for {incident_id}: {summary['completed_steps']}/{summary['total_steps']} steps completed")
        
        # Mark incident as handled
        if incident_id in self.active_incidents:
            self.active_incidents[incident_id]["plan_executed"] = True
            self.active_incidents[incident_id]["plan_summary"] = summary
    
    def cleanup_resolved_incidents(self):
        """Clean up resolved incidents and completed plans"""
        resolved_incidents = []
        
        for incident_id, incident in self.active_incidents.items():
            if incident.get("resolved", False) and incident.get("plan_executed", False):
                resolved_incidents.append(incident_id)
        
        for incident_id in resolved_incidents:
            del self.active_incidents[incident_id]
            if incident_id in self.active_plans:
                del self.active_plans[incident_id]
            self.log(f"Cleaned up resolved incident: {incident_id}")
    
    def run(self):
        """Main Felix loop"""
        self.log(f"Felix Commander starting (check interval: {self.check_interval}s)")
        
        try:
            while self.running:
                try:
                    # Detect new incidents
                    new_incidents = self.detect_incidents()
                    
                    # Generate and execute plans for new incidents
                    for incident in new_incidents:
                        plan = self.generate_recovery_plan(incident)
                        if plan:
                            # Execute plan in background thread
                            thread = threading.Thread(
                                target=self.execute_plan,
                                args=(incident["id"], plan),
                                daemon=True
                            )
                            thread.start()
                        else:
                            self.log(f"Failed to generate plan for incident {incident['id']}")
                    
                    # Clean up resolved incidents
                    self.cleanup_resolved_incidents()
                    
                    # Status report
                    if self.active_incidents:
                        self.log(f"Active incidents: {len(self.active_incidents)}, Active plans: {len(self.active_plans)}")
                    
                    # Wait for next check
                    time.sleep(self.check_interval)
                    
                except KeyboardInterrupt:
                    self.log("Interrupted by user")
                    break
                except Exception as e:
                    self.log(f"Error in main loop: {e}")
                    time.sleep(5)
                    
        except Exception as e:
            self.log(f"Fatal error: {e}")
        finally:
            self.cleanup()
            self.log("Felix Commander shutting down")
    
    def cleanup(self):
        """Clean up agent processes"""
        for agent_id, process in self.agent_processes.items():
            try:
                if process.poll() is None:
                    process.terminate()
                    process.wait(timeout=5)
            except Exception as e:
                self.log(f"Error cleaning up agent {agent_id}: {e}")
                try:
                    process.kill()
                except:
                    pass


def main():
    felix = FelixAgent()
    felix.run()


if __name__ == "__main__":
    main()

