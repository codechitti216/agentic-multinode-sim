# Auto-generated by Manus: Chaos Triage Arena scaffold

import json
import time
import argparse
import sys
from fastapi import FastAPI
import uvicorn
import requests


class ActionAgent:
    """Agent for executing recovery actions"""
    
    def __init__(self, port: int):
        self.port = port
        self.app = FastAPI(title="ActionAgent")
        self.dashboard_api_base = "http://127.0.0.1:8000/api"
        self.setup_routes()
    
    def setup_routes(self):
        @self.app.post("/run")
        async def run_action(step_data: dict):
            """Execute recovery action step"""
            try:
                result = self.execute_action(step_data)
                return {"success": True, "result": result}
            except Exception as e:
                return {"success": False, "error": str(e)}
    
    def execute_action(self, step_data: dict) -> dict:
        """Execute recovery action based on step type"""
        target_service = step_data.get("target_service", "unknown")
        step_type = step_data.get("step", "unknown")
        
        action_result = {
            "service": target_service,
            "step": step_type,
            "timestamp": time.time(),
            "actions_taken": [],
            "success": False,
            "details": {}
        }
        
        try:
            if step_type in ["restart_service", "start_service"]:
                result = self.restart_service(target_service)
                action_result["actions_taken"].append("restart_service")
                action_result["details"]["restart"] = result
                action_result["success"] = result.get("ok", False)
                
            elif step_type in ["recover_service", "service_recovery"]:
                result = self.recover_service(target_service)
                action_result["actions_taken"].append("recover_service")
                action_result["details"]["recovery"] = result
                action_result["success"] = result.get("ok", False)
                
            elif step_type in ["optimize_config", "config_optimization"]:
                result = self.optimize_configuration(target_service)
                action_result["actions_taken"].append("optimize_config")
                action_result["details"]["optimization"] = result
                action_result["success"] = result.get("ok", False)
                
            elif step_type in ["scale_or_restart", "scale_service"]:
                # For this demo, scaling means restart with recovery
                restart_result = self.restart_service(target_service)
                recover_result = self.recover_service(target_service)
                action_result["actions_taken"].extend(["restart_service", "recover_service"])
                action_result["details"]["restart"] = restart_result
                action_result["details"]["recovery"] = recover_result
                action_result["success"] = restart_result.get("ok", False) and recover_result.get("ok", False)
                
            else:
                # Generic recovery action
                result = self.generic_recovery(target_service, step_type)
                action_result["actions_taken"].append("generic_recovery")
                action_result["details"]["generic"] = result
                action_result["success"] = result.get("ok", False)
                
        except Exception as e:
            action_result["error"] = str(e)
            action_result["success"] = False
        
        return action_result
    
    def restart_service(self, service_name: str) -> dict:
        """Restart a service"""
        try:
            # Stop service first
            stop_response = requests.post(f"{self.dashboard_api_base}/actions/stop/{service_name}", timeout=10)
            time.sleep(2)  # Wait a bit
            
            # Start service
            start_response = requests.post(f"{self.dashboard_api_base}/actions/start/{service_name}", timeout=10)
            
            if start_response.status_code == 200:
                result = start_response.json()
                return {"ok": True, "message": "Service restarted successfully", "details": result}
            else:
                return {"ok": False, "error": f"Start failed with status {start_response.status_code}"}
                
        except Exception as e:
            return {"ok": False, "error": f"Restart failed: {str(e)}"}
    
    def recover_service(self, service_name: str) -> dict:
        """Recover a service from failure state"""
        try:
            # Try to call service recovery endpoint
            response = requests.post(f"{self.dashboard_api_base}/actions/recover/{service_name}", timeout=10)
            
            if response.status_code == 200:
                result = response.json()
                return {"ok": True, "message": "Service recovered successfully", "details": result}
            else:
                return {"ok": False, "error": f"Recovery failed with status {response.status_code}"}
                
        except Exception as e:
            return {"ok": False, "error": f"Recovery failed: {str(e)}"}
    
    def optimize_configuration(self, service_name: str) -> dict:
        """Optimize service configuration"""
        try:
            actions_taken = []
            
            # Remove artificial latency
            latency_response = requests.post(f"{self.dashboard_api_base}/actions/latency/{service_name}/0", timeout=10)
            if latency_response.status_code == 200:
                actions_taken.append("removed_artificial_latency")
            
            # Stop any CPU stress
            # Note: There's no direct "stop stress" endpoint, so we'll try recovery
            recover_response = requests.post(f"{self.dashboard_api_base}/actions/recover/{service_name}", timeout=10)
            if recover_response.status_code == 200:
                actions_taken.append("stopped_stress_tests")
            
            return {
                "ok": True,
                "message": "Configuration optimized",
                "actions_taken": actions_taken
            }
            
        except Exception as e:
            return {"ok": False, "error": f"Configuration optimization failed: {str(e)}"}
    
    def generic_recovery(self, service_name: str, step_type: str) -> dict:
        """Generic recovery action"""
        try:
            # Try recovery first
            recover_result = self.recover_service(service_name)
            
            if recover_result.get("ok"):
                return recover_result
            
            # If recovery fails, try restart
            restart_result = self.restart_service(service_name)
            
            return {
                "ok": restart_result.get("ok", False),
                "message": f"Generic recovery for {step_type}",
                "recovery_attempt": recover_result,
                "restart_attempt": restart_result
            }
            
        except Exception as e:
            return {"ok": False, "error": f"Generic recovery failed: {str(e)}"}
    
    def run(self):
        """Run the ActionAgent server"""
        print(f"ActionAgent starting on port {self.port}")
        uvicorn.run(self.app, host="127.0.0.1", port=self.port, log_level="warning")


def main():
    parser = argparse.ArgumentParser(description="ActionAgent - Recovery action execution")
    parser.add_argument("--port", type=int, required=True, help="Port to listen on")
    parser.add_argument("--step-data", type=str, help="JSON step data")
    
    args = parser.parse_args()
    
    # If step-data provided, run once and exit
    if args.step_data:
        try:
            step_data = json.loads(args.step_data)
            agent = ActionAgent(args.port)
            result = agent.execute_action(step_data)
            print(json.dumps(result))
            sys.exit(0)
        except Exception as e:
            print(json.dumps({"success": False, "error": str(e)}))
            sys.exit(1)
    
    # Otherwise run as server
    agent = ActionAgent(args.port)
    agent.run()


if __name__ == "__main__":
    main()

