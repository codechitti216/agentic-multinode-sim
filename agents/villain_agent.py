# Auto-generated by Manus: Chaos Triage Arena scaffold

import time
import random
import requests
import os
import json
from pathlib import Path


class VillainAgent:
    def __init__(self):
        self.attack_interval = int(os.getenv("VILLAIN_INTERVAL", "15"))
        self.dashboard_api_base = "http://127.0.0.1:8000/api"
        self.log_file = Path("villain.log")
        
        # Attack curriculum: escalating complexity
        self.attack_curriculum = [
            "kill",
            "inject_logical_failure", 
            "latency",
            "cpu_stress",
            "memory_leak",
            "multi"  # Multi-service cascade
        ]
        
        self.current_phase = 0
        self.attacks_in_phase = 0
        self.max_attacks_per_phase = 3
        
        # Service weights (higher = more likely to be targeted)
        self.service_weights = {
            "api_gateway": 3,      # Critical entry point
            "database_service": 3,  # Critical data layer
            "user_service": 2,      # Important business logic
            "payment_service": 2,   # Important business logic
            "echo_service": 1       # Less critical
        }
        
        self.running = True
        
    def log(self, message: str):
        """Log message to console and file"""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        log_entry = f"[{timestamp}] [VILLAIN] {message}"
        print(log_entry)
        
        try:
            with open(self.log_file, 'a') as f:
                f.write(log_entry + '\n')
        except Exception as e:
            print(f"[VILLAIN] Failed to write to log file: {e}")
    
    def choose_target_service(self) -> str:
        """Choose a target service based on weights"""
        services = list(self.service_weights.keys())
        weights = list(self.service_weights.values())
        return random.choices(services, weights=weights)[0]
    
    def get_current_attack_type(self) -> str:
        """Get current attack type based on curriculum phase"""
        if self.current_phase >= len(self.attack_curriculum):
            # Cycle through all attack types randomly
            return random.choice(self.attack_curriculum[:-1])  # Exclude 'multi'
        
        return self.attack_curriculum[self.current_phase]
    
    def advance_curriculum(self):
        """Advance to next phase of attack curriculum"""
        self.attacks_in_phase += 1
        
        if self.attacks_in_phase >= self.max_attacks_per_phase:
            self.current_phase += 1
            self.attacks_in_phase = 0
            
            if self.current_phase < len(self.attack_curriculum):
                attack_type = self.attack_curriculum[self.current_phase]
                self.log(f"Advancing to curriculum phase {self.current_phase}: {attack_type}")
            else:
                self.log("Curriculum complete, entering random attack mode")
    
    def execute_kill_attack(self, target: str) -> dict:
        """Execute kill attack"""
        try:
            response = requests.post(f"{self.dashboard_api_base}/actions/kill/{target}", timeout=10)
            return response.json()
        except Exception as e:
            return {"ok": False, "error": str(e)}
    
    def execute_inject_failure(self, target: str) -> dict:
        """Execute logical failure injection"""
        failure_types = ["database_error", "timeout", "auth_failure", "rate_limit"]
        failure_type = random.choice(failure_types)
        
        try:
            response = requests.post(f"{self.dashboard_api_base}/actions/inject/{target}/{failure_type}", timeout=10)
            return response.json()
        except Exception as e:
            return {"ok": False, "error": str(e)}
    
    def execute_latency_attack(self, target: str) -> dict:
        """Execute latency attack"""
        latency_ms = random.choice([100, 250, 500, 1000, 2000])
        
        try:
            response = requests.post(f"{self.dashboard_api_base}/actions/latency/{target}/{latency_ms}", timeout=10)
            return response.json()
        except Exception as e:
            return {"ok": False, "error": str(e)}
    
    def execute_cpu_stress(self, target: str) -> dict:
        """Execute CPU stress attack"""
        intensity = random.choice([30, 50, 70, 90])
        
        try:
            response = requests.post(f"{self.dashboard_api_base}/actions/cpu-stress/{target}/{intensity}", timeout=10)
            return response.json()
        except Exception as e:
            return {"ok": False, "error": str(e)}
    
    def execute_memory_leak(self, target: str) -> dict:
        """Execute memory leak attack"""
        size_mb = random.choice([50, 100, 200, 300])
        
        try:
            response = requests.post(f"{self.dashboard_api_base}/actions/memory-leak/{target}/{size_mb}", timeout=10)
            return response.json()
        except Exception as e:
            return {"ok": False, "error": str(e)}
    
    def execute_multi_attack(self) -> dict:
        """Execute multi-service cascade attack"""
        # Attack multiple services in sequence to create cascading failures
        targets = random.sample(list(self.service_weights.keys()), k=min(3, len(self.service_weights)))
        attack_types = ["latency", "cpu_stress", "inject_logical_failure"]
        
        results = []
        
        for target in targets:
            attack_type = random.choice(attack_types)
            self.log(f"Multi-attack: {attack_type} on {target}")
            
            if attack_type == "latency":
                result = self.execute_latency_attack(target)
            elif attack_type == "cpu_stress":
                result = self.execute_cpu_stress(target)
            else:
                result = self.execute_inject_failure(target)
            
            results.append({"target": target, "attack": attack_type, "result": result})
            
            # Small delay between attacks
            time.sleep(1)
        
        return {"ok": True, "multi_attack_results": results}
    
    def execute_attack(self) -> dict:
        """Execute an attack based on current curriculum phase"""
        attack_type = self.get_current_attack_type()
        target = self.choose_target_service()
        
        self.log(f"Executing {attack_type} attack on {target}")
        
        if attack_type == "kill":
            result = self.execute_kill_attack(target)
        elif attack_type == "inject_logical_failure":
            result = self.execute_inject_failure(target)
        elif attack_type == "latency":
            result = self.execute_latency_attack(target)
        elif attack_type == "cpu_stress":
            result = self.execute_cpu_stress(target)
        elif attack_type == "memory_leak":
            result = self.execute_memory_leak(target)
        elif attack_type == "multi":
            result = self.execute_multi_attack()
        else:
            result = {"ok": False, "error": f"Unknown attack type: {attack_type}"}
        
        # Log result
        if result.get("ok"):
            self.log(f"Attack successful: {attack_type} on {target}")
        else:
            self.log(f"Attack failed: {attack_type} on {target} - {result.get('error', 'unknown error')}")
        
        # Advance curriculum
        self.advance_curriculum()
        
        return result
    
    def run(self):
        """Main villain loop"""
        self.log(f"Villain agent starting (attack interval: {self.attack_interval}s)")
        self.log(f"Attack curriculum: {' â†’ '.join(self.attack_curriculum)}")
        
        try:
            while self.running:
                try:
                    # Execute attack
                    self.execute_attack()
                    
                    # Wait for next attack
                    self.log(f"Waiting {self.attack_interval}s until next attack...")
                    time.sleep(self.attack_interval)
                    
                except KeyboardInterrupt:
                    self.log("Interrupted by user")
                    break
                except Exception as e:
                    self.log(f"Error during attack: {e}")
                    time.sleep(5)  # Wait before retrying
                    
        except Exception as e:
            self.log(f"Fatal error: {e}")
        finally:
            self.log("Villain agent shutting down")


def main():
    villain = VillainAgent()
    villain.run()


if __name__ == "__main__":
    main()

