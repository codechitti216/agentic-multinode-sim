# Auto-generated by Manus: Chaos Triage Arena scaffold

from base_service import BaseService
from fastapi import HTTPException
import random
import time


class PaymentService(BaseService):
    def __init__(self):
        super().__init__("payment_service", 8004, ["database_service"])
        self._setup_payment_routes()
    
    def _setup_payment_routes(self):
        @self.app.get("/payments")
        async def get_payments():
            try:
                # Get payments from database service
                payments_data = self.call_dependency("database_service", "/payments")
                return {
                    "service": "payment_service",
                    "payments": payments_data.get("payments", [])
                }
            except HTTPException as e:
                raise e
        
        @self.app.post("/process")
        async def process_payment():
            try:
                # Simulate payment processing
                time.sleep(random.uniform(0.1, 0.3))
                
                # Check database connectivity
                db_status = self.call_dependency("database_service", "/query")
                
                # Simulate payment processing result
                success = random.random() > 0.1  # 90% success rate
                
                if success:
                    # Create payment record
                    payment_result = self.call_dependency("database_service", "/payments")
                    return {
                        "service": "payment_service",
                        "status": "success",
                        "transaction_id": f"txn_{int(time.time())}",
                        "payment_record": payment_result
                    }
                else:
                    raise HTTPException(status_code=402, detail="Payment processing failed")
                    
            except HTTPException as e:
                raise e
        
        @self.app.get("/balance/{user_id}")
        async def get_balance(user_id: int):
            try:
                # Get user payments from database
                payments_data = self.call_dependency("database_service", "/payments")
                payments = payments_data.get("payments", [])
                
                user_payments = [p for p in payments if p["user_id"] == user_id]
                balance = sum(p["amount"] for p in user_payments if p["status"] == "completed")
                
                return {
                    "service": "payment_service",
                    "user_id": user_id,
                    "balance": balance,
                    "payment_count": len(user_payments)
                }
            except HTTPException as e:
                raise e
        
        @self.app.post("/refund")
        async def process_refund():
            try:
                # Simulate refund processing
                time.sleep(random.uniform(0.05, 0.15))
                
                # Check database connectivity
                db_status = self.call_dependency("database_service", "/query")
                
                return {
                    "service": "payment_service",
                    "refund_status": "processed",
                    "refund_id": f"ref_{int(time.time())}",
                    "database_status": db_status
                }
            except HTTPException as e:
                raise e


if __name__ == "__main__":
    service = PaymentService()
    service.run()

