# Auto-generated by Manus: Chaos Triage Arena scaffold

import time
from typing import Dict, List, Any


class StubPlanner:
    """Simple stub planner that generates basic recovery plans"""
    
    def __init__(self):
        self.plan_templates = {
            "service_down": [
                {"step": "analyze_logs", "agent": "LogAgent", "dependencies": []},
                {"step": "check_metrics", "agent": "MetricAgent", "dependencies": []},
                {"step": "probe_dependencies", "agent": "ProbeAgent", "dependencies": ["analyze_logs"]},
                {"step": "restart_service", "agent": "ActionAgent", "dependencies": ["check_metrics", "probe_dependencies"]}
            ],
            "service_unhealthy": [
                {"step": "analyze_logs", "agent": "LogAgent", "dependencies": []},
                {"step": "check_metrics", "agent": "MetricAgent", "dependencies": []},
                {"step": "probe_service", "agent": "ProbeAgent", "dependencies": []},
                {"step": "recover_service", "agent": "ActionAgent", "dependencies": ["analyze_logs", "check_metrics", "probe_service"]}
            ],
            "high_latency": [
                {"step": "check_metrics", "agent": "MetricAgent", "dependencies": []},
                {"step": "analyze_performance", "agent": "LogAgent", "dependencies": []},
                {"step": "probe_dependencies", "agent": "ProbeAgent", "dependencies": ["check_metrics"]},
                {"step": "optimize_config", "agent": "ActionAgent", "dependencies": ["analyze_performance", "probe_dependencies"]}
            ],
            "resource_exhaustion": [
                {"step": "check_metrics", "agent": "MetricAgent", "dependencies": []},
                {"step": "analyze_resource_usage", "agent": "LogAgent", "dependencies": []},
                {"step": "probe_system", "agent": "ProbeAgent", "dependencies": ["check_metrics"]},
                {"step": "scale_or_restart", "agent": "ActionAgent", "dependencies": ["analyze_resource_usage", "probe_system"]}
            ]
        }
    
    def classify_incident(self, incident: Dict[str, Any]) -> str:
        """Classify the type of incident based on symptoms"""
        service_name = incident.get("service")
        status = incident.get("status", {})
        metrics = incident.get("metrics", {})
        
        # Check if service is down
        if not status.get("running", False):
            return "service_down"
        
        # Check if service is unhealthy
        if not status.get("healthy", False):
            return "service_unhealthy"
        
        # Check for high resource usage
        cpu_percent = metrics.get("cpu_percent", 0)
        memory_mb = metrics.get("memory_mb", 0)
        
        if cpu_percent > 80 or memory_mb > 500:  # Arbitrary thresholds
            return "resource_exhaustion"
        
        # Check for artificial latency (indicating performance issues)
        if metrics.get("artificial_latency", 0) > 100:
            return "high_latency"
        
        # Default to unhealthy if we can't classify
        return "service_unhealthy"
    
    def generate_plan(self, incident: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate a recovery plan for the given incident"""
        incident_type = self.classify_incident(incident)
        
        # Get template for this incident type
        template = self.plan_templates.get(incident_type, self.plan_templates["service_unhealthy"])
        
        # Create plan with incident context
        plan = []
        for step_template in template:
            step = {
                "id": f"{incident.get('service', 'unknown')}_{step_template['step']}_{int(time.time())}",
                "step": step_template["step"],
                "agent": step_template["agent"],
                "dependencies": step_template["dependencies"],
                "incident_type": incident_type,
                "target_service": incident.get("service"),
                "status": "pending",
                "created_at": time.time()
            }
            plan.append(step)
        
        return plan
    
    def get_ready_steps(self, plan: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Get steps that are ready to execute (dependencies satisfied)"""
        ready_steps = []
        
        for step in plan:
            if step["status"] != "pending":
                continue
            
            # Check if all dependencies are completed
            dependencies_satisfied = True
            for dep_step in step["dependencies"]:
                dep_completed = any(
                    s["step"] == dep_step and s["status"] == "completed"
                    for s in plan
                )
                if not dep_completed:
                    dependencies_satisfied = False
                    break
            
            if dependencies_satisfied:
                ready_steps.append(step)
        
        return ready_steps
    
    def update_step_status(self, plan: List[Dict[str, Any]], step_id: str, status: str, result: Dict[str, Any] = None):
        """Update the status of a step in the plan"""
        for step in plan:
            if step["id"] == step_id:
                step["status"] = status
                step["updated_at"] = time.time()
                if result:
                    step["result"] = result
                break
    
    def is_plan_complete(self, plan: List[Dict[str, Any]]) -> bool:
        """Check if all steps in the plan are completed"""
        return all(step["status"] in ["completed", "failed"] for step in plan)
    
    def get_plan_summary(self, plan: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Get a summary of the plan execution"""
        total_steps = len(plan)
        completed_steps = len([s for s in plan if s["status"] == "completed"])
        failed_steps = len([s for s in plan if s["status"] == "failed"])
        pending_steps = len([s for s in plan if s["status"] == "pending"])
        running_steps = len([s for s in plan if s["status"] == "running"])
        
        return {
            "total_steps": total_steps,
            "completed_steps": completed_steps,
            "failed_steps": failed_steps,
            "pending_steps": pending_steps,
            "running_steps": running_steps,
            "completion_rate": completed_steps / total_steps if total_steps > 0 else 0,
            "is_complete": self.is_plan_complete(plan)
        }


def main():
    # Simple test of the planner
    planner = StubPlanner()
    
    # Test incident
    incident = {
        "service": "api_gateway",
        "status": {"running": False, "healthy": False},
        "metrics": {"cpu_percent": 0, "memory_mb": 0}
    }
    
    plan = planner.generate_plan(incident)
    print("Generated plan:")
    for step in plan:
        print(f"  {step['step']} ({step['agent']}) - deps: {step['dependencies']}")
    
    print(f"\nPlan summary: {planner.get_plan_summary(plan)}")


if __name__ == "__main__":
    main()

