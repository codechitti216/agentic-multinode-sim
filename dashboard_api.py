# Auto-generated by Manus: Chaos Triage Arena scaffold

import json
import os
import time
import threading
from pathlib import Path
from typing import Dict, Any
import argparse

from fastapi import FastAPI, Response, HTTPException, Request
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
import uvicorn

from super_tool import SuperTool
import requests


class DashboardAPI:
	def __init__(self, host: str = "127.0.0.1", port: int = 8000):
		self.host = host
		self.port = port
		self.app = FastAPI(title="Chaos Triage Arena Dashboard")
		self.super_tool = SuperTool()
		
		# Persistence settings
		self.persist_enabled = os.getenv("ACTION_HISTORY_PERSIST", "false").lower() == "jsonl"
		self.data_dir = Path("data")
		self.data_dir.mkdir(exist_ok=True)
		(self.data_dir / 'recordings').mkdir(exist_ok=True)
		
		# Background flusher
		self._last_flushed_count = 0
		if self.persist_enabled:
			self._start_background_flusher()
			self._load_persisted_data()
		
		self.monitor_api_base = "http://127.0.0.1:9000/api"
		
		self._setup_routes()
		self._mount_static_files()
	
	def _forward_action(self, action, service_name, param=None):
		url = f"{self.monitor_api_base}/actions/{action}/{service_name}"
		if param is not None:
			url += f"/{param}"
		try:
			resp = requests.post(url, timeout=5)
			return resp.content, resp.status_code
		except Exception as e:
			return json.dumps({"ok": False, "error": f"Monitor unavailable: {str(e)}"}).encode("utf-8"), 503
	
	def _setup_routes(self):
		@self.app.get("/")
		async def serve_dashboard():
			dashboard_path = Path("dashboard/index.html")
			if dashboard_path.exists():
				return FileResponse(dashboard_path)
			else:
				return {"error": "Dashboard not found", "path": str(dashboard_path.absolute())}
		
		@self.app.get("/api/health")
		async def api_health():
			payload = {"status": "healthy", "timestamp": time.time()}
			content = json.dumps(payload, ensure_ascii=False).encode("utf-8")
			print(f"[DEBUG] Returning {len(content)} bytes for /api/health")
			return Response(content=content, media_type="application/json")
		
		@self.app.get("/api/status")
		async def api_status():
			try:
				with open('data/status.json', 'r', encoding='utf-8') as f:
					status = json.load(f)
				return status['services']
			except Exception as e:
				print('[DASHBOARD_API] status.json error:', e)
				return {}
		
		@self.app.get("/api/metrics")
		async def api_metrics():
			try:
				with open('data/status.json', 'r', encoding='utf-8') as f:
					status = json.load(f)
				# Compute metrics from status['services']
				metrics = {}
				for name, svc in status.get('services', {}).items():
					metrics[name] = {
						'cpu_percent': svc.get('cpu_percent', 0),
						'memory_mb': svc.get('memory_mb', 0),
						'pid': svc.get('pid'),
						'running': svc.get('running'),
						'healthy': svc.get('healthy'),
						'failed': svc.get('failed'),
					}
				return metrics
			except Exception as e:
				print('[DASHBOARD_API] status.json error:', e)
				return {}
		
		@self.app.get("/api/action-history")
		async def api_action_history():
			try:
				r = requests.get(f"{self.monitor_api_base}/action-history", timeout=5)
				content = r.content
				return Response(content=content, media_type="application/json", status_code=r.status_code)
			except Exception as e:
				payload = {"history": [], "error": f"Monitor unavailable: {str(e)}"}
				return Response(content=json.dumps(payload).encode("utf-8"), media_type="application/json", status_code=503)
		
		@self.app.get("/api/action-metrics")
		async def api_action_metrics():
			try:
				r = requests.get(f"{self.monitor_api_base}/action-metrics", timeout=5)
				content = r.content
				return Response(content=content, media_type="application/json", status_code=r.status_code)
			except Exception as e:
				payload = {"error": f"Monitor unavailable: {str(e)}"}
				return Response(content=json.dumps(payload).encode("utf-8"), media_type="application/json", status_code=503)
		
		@self.app.post("/api/upload-recording")
		async def api_upload_recording(request: Request):
			try:
				raw = await request.body()
				if not raw:
					return Response(content=json.dumps({"ok": False, "error": "empty body"}).encode("utf-8"), media_type="application/json", status_code=400)
				name = f"dashboard_{int(time.time())}.webm"
				out_path = self.data_dir / 'recordings' / name
				with open(out_path, 'wb') as f:
					f.write(raw)
				return Response(content=json.dumps({"ok": True, "path": str(out_path)}).encode("utf-8"), media_type="application/json")
			except Exception as e:
				return Response(content=json.dumps({"ok": False, "error": str(e)}).encode("utf-8"), media_type="application/json", status_code=500)
		
		# Action endpoints
		@self.app.post("/api/actions/start/{service_name}")
		async def api_start_service(service_name: str):
			print(f"[DASHBOARD_API] Received action=start for service={service_name}")
			content, status = self._forward_action("start", service_name)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/start/{service_name}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/stop/{service_name}")
		async def api_stop_service(service_name: str):
			print(f"[DASHBOARD_API] Received action=stop for service={service_name}")
			content, status = self._forward_action("stop", service_name)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/stop/{service_name}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/kill/{service_name}")
		async def api_kill_service(service_name: str):
			print(f"[DASHBOARD_API] Received action=kill for service={service_name}")
			content, status = self._forward_action("kill", service_name)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/kill/{service_name}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/inject/{service_name}/{failure_type}")
		async def api_inject_failure(service_name: str, failure_type: str):
			print(f"[DASHBOARD_API] Received action=inject_{failure_type} for service={service_name}")
			content, status = self._forward_action("inject", service_name, failure_type)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/inject/{service_name}/{failure_type}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/recover/{service_name}")
		async def api_recover_service(service_name: str):
			print(f"[DASHBOARD_API] Received action=recover for service={service_name}")
			content, status = self._forward_action("recover", service_name)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/recover/{service_name}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/latency/{service_name}/{latency_ms}")
		async def api_set_latency(service_name: str, latency_ms: int):
			print(f"[DASHBOARD_API] Received action=set_latency for service={service_name}, latency={latency_ms}")
			content, status = self._forward_action("latency", service_name, latency_ms)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/latency/{service_name}/{latency_ms}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/cpu-stress/{service_name}/{intensity}")
		async def api_cpu_stress(service_name: str, intensity: int):
			print(f"[DASHBOARD_API] Received action=cpu_stress for service={service_name}, intensity={intensity}")
			content, status = self._forward_action("cpu-stress", service_name, intensity)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/cpu-stress/{service_name}/{intensity}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/actions/memory-leak/{service_name}/{size_mb}")
		async def api_memory_leak(service_name: str, size_mb: int):
			print(f"[DASHBOARD_API] Received action=memory_leak for service={service_name}, size={size_mb}MB")
			content, status = self._forward_action("memory-leak", service_name, size_mb)
			print(f"[DEBUG] Returning {len(content)} bytes for /api/actions/memory-leak/{service_name}/{size_mb}")
			return Response(content=content, media_type="application/json", status_code=status)
		
		@self.app.post("/api/force-kill-port/{port}")
		async def force_kill_port(port: int):
			# Only allow killing ports defined in arena.json
			allowed_ports = {svc["port"] for svc in self.super_tool.arena_config["services"].values()}
			if port not in allowed_ports:
				raise HTTPException(status_code=400, detail=f"Port {port} is not managed by the arena.")
			proc_info = self.super_tool._find_process_on_port(port)
			if not proc_info:
				return {"ok": False, "error": f"No process found on port {port}"}
			pid, cmdline = proc_info
			try:
				import psutil
				p = psutil.Process(pid)
				p.terminate()
				try:
					p.wait(timeout=3)
				except Exception:
					p.kill()
				return {"ok": True, "killed_pid": pid, "cmdline": cmdline}
			except Exception as e:
				return {"ok": False, "error": str(e), "pid": pid, "cmdline": cmdline}
	
	def _mount_static_files(self):
		# Mount dashboard static files if directory exists
		dashboard_dir = Path("dashboard")
		if dashboard_dir.exists():
			self.app.mount("/static", StaticFiles(directory=dashboard_dir), name="static")
	
	def _start_background_flusher(self):
		"""Start background thread to flush action history to JSONL"""
		def flusher():
			while True:
				try:
					self._flush_action_history()
					time.sleep(1)  # Flush every second
				except Exception as e:
					print(f"[ERROR] Background flusher error: {e}")
					time.sleep(5)  # Wait longer on error
		
		thread = threading.Thread(target=flusher, daemon=True)
		thread.start()
		print("[INFO] Background action history flusher started")
	
	def _flush_action_history(self):
		"""Flush new action history entries to JSONL file"""
		history = self.super_tool.get_action_history()
		new_entries = history[self._last_flushed_count:]
		
		if new_entries:
			jsonl_path = self.data_dir / "action_history.jsonl"
			
			# Check file size and rotate if needed
			if jsonl_path.exists() and jsonl_path.stat().st_size > 5 * 1024 * 1024:  # 5MB
				self._rotate_jsonl_file(jsonl_path)
			
			# Append new entries
			with open(jsonl_path, 'a') as f:
				for entry in new_entries:
					f.write(json.dumps(entry) + '\n')
			
			self._last_flushed_count = len(history)
	
	def _rotate_jsonl_file(self, file_path: Path):
		"""Rotate JSONL file, keeping up to 5 rotated files"""
		# Move existing rotated files
		for i in range(4, 0, -1):
			old_file = file_path.with_suffix(f".jsonl.{i}")
			new_file = file_path.with_suffix(f".jsonl.{i+1}")
			if old_file.exists():
				if new_file.exists():
					new_file.unlink()
				old_file.rename(new_file)
		
		# Move current file to .1
		rotated_file = file_path.with_suffix(".jsonl.1")
		if rotated_file.exists():
			rotated_file.unlink()
		file_path.rename(rotated_file)
		
		print(f"[INFO] Rotated {file_path} to {rotated_file}")
	
	def _load_persisted_data(self):
		"""Load persisted action history from JSONL on startup"""
		jsonl_path = self.data_dir / "action_history.jsonl"
		if not jsonl_path.exists():
			return
		
		# Load last 30 minutes of data
		cutoff_time = time.time() - (30 * 60)  # 30 minutes ago
		loaded_count = 0
		
		try:
			with open(jsonl_path, 'r') as f:
				for line in f:
					try:
						entry = json.loads(line.strip())
						if entry.get("timestamp", 0) >= cutoff_time:
							self.super_tool._action_history.append(entry)
							loaded_count += 1
					except json.JSONDecodeError:
						continue
			
			self._last_flushed_count = len(self.super_tool._action_history)
			print(f"[INFO] Loaded {loaded_count} action history entries from persistence")
			
		except Exception as e:
			print(f"[ERROR] Failed to load persisted data: {e}")
	
	def run(self):
		"""Run the dashboard API server"""
		print(f"üìä API will be available at: http://{self.host}:{self.port}")
		if self.persist_enabled:
			print(f"üìÅ Action history persistence enabled: {self.data_dir}/action_history.jsonl")
		uvicorn.run(self.app, host=self.host, port=self.port, log_level="info")


def main():
	parser = argparse.ArgumentParser(description="Chaos Triage Arena Dashboard API")
	parser.add_argument("--host", default=os.getenv("DASHBOARD_HOST", "127.0.0.1"), help="Host to bind to")
	parser.add_argument("--port", type=int, default=int(os.getenv("DASHBOARD_PORT", "8000")), help="Port to bind to")
	
	args = parser.parse_args()
	
	dashboard = DashboardAPI(host=args.host, port=args.port)
	dashboard.run()


if __name__ == "__main__":
	main()

